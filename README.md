# OpenCV_IrisRecognition

GR5293 Group Project (Patrick Kwon, Lingyi Zhao, Liangchen Xing)

### IrisRecognition.py: (main function)

In this project, we use several separate functions for iris recognition. They are IrisLocalization, IrisNormalization, IrisEnhancement, FeatureExtraction, and IrisMatching as well as Performance Evaluation. 

For Function 'readImg()', we use ‘url’ as the input file string, and it outputs an 
grayscale image array. This function is for load image to numpy array. Because our dataset are stored in sub folders, based on the folder structure, we use:
trainNames = ['data/' + '{0:03d}'.format(ppl) + '/1/' + '{0:03d}'.format(ppl) + '_1_'  for ppl in 
list(range(1, 109))]
trainNames = [[x + str(trial) + '.bmp' for trial in list(range(1, 4))] for x in trainNames]
train_image = pd.DataFrame(columns=['Image'])
train_image['Image'] = list(map(readImg, np.ravel(trainNames)))
train_image.index = np.ravel(trainNames)

This 'data' is the data folder name of our file. Within this folder, we have 108 subfolders, and within each subfolder, we also have two 'second-level subfolders', and each 'second-level subfolder' contains three images. We pick the first 'second-level subfolder' as the train_image, and stored all the 108 names of subfolders into testNames as 'string' type. Because the Python index will start at 0, and the specific number second argument of 'range(,)' function will not be contained in the list. Therefore,we use range(1,109) to cover the 108 samples. Because in each subfolder, we have 3 training picture, therefore, we use 'list(range(1, 4))] for x in 
trainNames'.
So it will gives output such that: 
 'data/001/1/001_1_',
 'data/002/1/002_1_',
 'data/003/1/003_1_',
 'data/004/1/004_1_',
 'data/005/1/005_1_',

Similarly, we store the image from second 'second-level subfolder' into test_image.
Because in each subfolder, we have 4 training picture, therefore, we use 'for trial in list(range(1, 5))] for x in testNames'.

### IrisLocalization.py: 
Here we use 8 separate functions for localization part.

A)	function： projection

1)	Logic explain:
Projection: horizontal and vertical projection of image. The projection function is build for 
project all pixel values to a vertical line and horizontal line separately, and then sum them up 
separately. It takes 'img' as the argument for this function. It will be used in localization function. The 
projection process will be implemented by summing the row pixel values and column pixel 
values. The first for loop will be used to sum the row pixel values for the image and stores in 'sumRows' 
list. The second for loop will be used to sum the column pixel values for the image and stores in 
'sumCols' list.
# Ignore the pixels in boundary of image (width: half of window (30)) for better approximation.

2)	Parameter explain:

k1 = 5 is the kernel size for first bilateral filter (pupil identification)
k2 = 13 is the kernel size for first bilateral filter (iris identification)
window = 60 is the size of window for subsetting image (120 * 120)
thresh1 = 80 is the Binary image thresholding value for pupil
thresh2 = 155 is the Binary image thresholding value for iris (155, 170)
scope1 = 1.6 is the Lower boundary for iris radius size in respect to pupil radius
scope2 = 3.6 is the Upper boundary for iris radius size in respect to iris radius
hough_list = [[20, 20], [15, 15], [10, 10], [5, 5]]  is the hough variables for hough circles

B)	function 'subsetting':

1)	Logic explain:
This 'subsetting' function takes 'img','posX','posY',and 'window' as its arguments.
It will outputs a subset image, based on the position of pupil.

2)	Parameter explain:
The 'img' is the input image array.
The 'posX' and 'poxY' are the coordinate of pupil center. 
The 'window' is the a window size.
Based on the corrdinate of pupil's center, 'window' will helps us to construct a sub-picture that 
covers the center of pupil.

C)	function 'thresholding':

1)	Logic explain:
The function 'thresholding' will be used to output the coordinate of pupils center. It takes 'orig', 
'posX', 'posY', 'window', 'otsu=True', 'thresh=150' as its function arguments.

2)	Parameter explain:
The 'orig' is the input of image array. 
The 'posX' and 'posY' are the coordinate of pupil center, which will be generated by 'projection' 
function in the following code.
The 'window' is the argument that will be used in the 'subsetting' function. We explain this 
parameter in subsetting function above.
'otsu = True' is the condition parameter. If it is true, then we will use 'cv2.THRESH_BINARY_INV' 
plus 'cv2.THRESH_OTSU' method in 'cv2.threshold' function. Otherwise, we only use 
'cv2.THRESH_BINARY_INV'.
The 'thresh = 150' is the parameter that used to binarize image base on thresholding and 
getting center of pupil from moments. 
This function will use cv.moment method to generate more accurate corrdinate for the pupil 
center.

D)	Function ‘boundary’:

1)	Logic explain: 
This 'boundary' function will decide whether the iris center is inside pupil or not. 
If the iris center is inside the pupil, it returns True. Otherwise, False.

2)	Parameter explain: 
It takes 'x1', 'x2', 'y1', 'y2', and 'r' as its arguments.
x1,y1 are the coordinate of pupil center, and x2,y2 are the doorinate of iris center. 
It will be used in the 'circle_detectX' function in order to find the pupil.

E)	function 'circle_detect(edges, dp = 20, minR = 20, maxR = 0)':

1)	Logic explain: 
This function 'circle_detect(edges, dp = 20, minR = 20, maxR = 0)' will be used to find the pupil.

2)	Parameter explain: 
It takes 'edges', 'dp', 'minR', 'maxR' as its four arguments. 
The 'edge' is the input of image that possibly will be used by 'cv2.HoughCircles'. Based on the 
gradient information,  'cv2.HoughCircles' will draw circles. In our following code, 'edge' is 
generally used after canny Opeartor.
It will be used in 'IrisLoc2' function helping to draw the pupil boundary.

F)	Function 'circle_detectX':

1)	Logic explain:
This 'circle_detectX' function is an alternate version of circle_detect, and it also uses houghcircles and boundary to find the iris.
It takes 'edges', 'dp', 'posX', 'posY', 'radius', 'minR = 20', 'maxR = 0' as its arguments.

2)	Parameter explain:
edges are the image array that has been filtered by canny Opeartor. 
The 'posX' and 'posY' are the coordinate of pupil center.
the 'radius' is the pupil radius.
we set 'minR = 20' for minimum pupil radius, and 'maxR = 0' for minimum pupil radius.

In the very beginning, we have asserted that:
hough_list = [[20, 20], [15, 15], [10, 10], [5, 5]] #hough variables for hough circles
This will be used in 'circle_detectX' function.
we set index i = 0, and set while loop for generating the pupil's circle. The hough_list will be 
applied inside this while loop. the loop will try all the element from hough_list and use 
'cv2.HoughCircles' to generate circles until circles' length is greater than one. 

G)	Function ’IrisLoc2(orig, name)‘:

1)	Logic explain: 
’IrisLoc2(orig, name)‘ is a funtion that combines all the previous functions.
it takes two arguments: 'orig' and 'name'. This function generates the coordinate of pupil's 
center and pupil radius first, and then generates the coordinate of iris and radius. For generating 
pupil's center coordinate and radius, it applies 'cv2.filter2D' to filter the original image first. And 
then generte thresholding image. After that, it applied Canny Operator then HoughCircles in 
order to generate the circle. For generating iris' center coordinate and radius, it binarized the 
filtered iamge first. Then it applies 'Canny operator' to generate the edge of the image, and 
uses'circle_detectX' function to generates the circle of iris.

2)	Parameter explain: 
'orig' is the input for image array. 
'name' is the string for image file's name.

H)	function 'IrisLoc(orig, name)':

1)	Logic explain: 
This function 'IrisLoc(orig, name)' is for generating the coordinate of center of pupil, radius of 
pupil, center of iris and radius of iris respectively. This function combines all the functions we 
defined before. It initially genearates coordinate for pupil's center and radius, then generates 
coordinate for iris center and radius. Specifically, it applied 'projection' function first, then find 
approximate pupil coordinates. After that, it applies 'thresholding' function to binarize the image. 
After that, we apply "Canny Operator" and "circle_detect" functions to generate the coordinate 
of pupil's center and radius of pupil. Then, we apply biliteral 2-D linear filter to the orginal image. 
Again, we apply 'cv2.threshold', 'Canny Operator', and 'circle_detectX' to the filtered image array, 
just like we did in the 'IrisLoc2' function. And we did set 'typeError' exeption. If we cannot 
generate either pupils' center and radius or iris' center and radius, we will then turn to use 
IrisLoc2 function.  

2)	Parameter explain: 
'orig' is the input for image array. 
'name' is the string for image file's name.